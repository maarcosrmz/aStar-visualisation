// Inspired by https://en.wikipedia.org/wiki/A*_search_algorithm

#include <iostream>
#include <unordered_map>
#include <vector>
#include <set>
#include <deque>
#include <queue>
#include <cmath>
#include <limits>

const uint32_t WIDTH = 12;
const uint32_t HEIGHT = 9;

// https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
const uint32_t D  = 10;
const uint32_t D2 = 14;

static inline uint32_t min(uint32_t a, uint32_t b) {
    return (a < b) ? a : b;
}

// https://stackoverflow.com/questions/16749723/how-i-can-find-value-in-priority-queue
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> class my_priority_queue : public std::priority_queue<T, Container, Compare>
{
public:
    typedef typename
        std::priority_queue<
        T,
        Container,
        Compare>::container_type::const_iterator const_iterator;

    const_iterator find(const T&val) const
    {
        auto first = this->c.cbegin();
        auto last = this->c.cend();
        while (first != last) {
            if (*first == val) return first;
            ++first;
        }
        return last;
    }

    typename Container::iterator begin() {
        return std::priority_queue<T, Container, Compare>::c.begin();
    }

    typename Container::iterator end() {
        return std::priority_queue<T, Container, Compare>::c.end();
    }
};

struct Node {
    int32_t x;
    int32_t y;

    int32_t gScore;
    int32_t fScore;

    std::vector<Node> getNeighbours() const {
        std::vector<Node> neighbours;

        for (int32_t xi = 0; xi < 3; xi++) {
            // If the neighbour is out of bounds: ignore
            if (x == 0 && xi == 0) continue;
            if (x == WIDTH - 1 && xi == 2) continue;

            for (int32_t yi = 0; yi < 3; yi++) {
                // If the neighbour is out of bounds: ignore
                if (y == 0 && yi == 0) continue;
                if (y == HEIGHT - 1 && yi == 2) continue;

                // Hinder from treating itself as a neighbour
                if (xi - 1 == 0 && yi - 1 == 0) continue;

                // Set neighbour coordinates and add to neighbour list
                Node neighbour = { x + (xi - 1), y + (yi - 1), std::numeric_limits<int32_t>::max(), std::numeric_limits<int32_t>::max() };
                neighbours.push_back(neighbour);    
            }
        }

        return neighbours;
    }

    // https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    float getDistanceFrom(const Node &node) const {
        uint32_t dx = abs(x - node.x);
        uint32_t dy = abs(y - node.y);
        return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy);
    }

    inline bool operator== (const Node &node) const {
        return (x == node.x) && (y == node.y);
    }
};

// http://availableimagination.com/unordered-map-with-custom-structures/
struct NodeHash {
    inline size_t operator() (const Node &node) const {
        return (node.x * 73856093) ^ (node.y * 19349663);
    }
};

struct NodeComp {
    inline bool operator() (const Node &node1, const Node &node2) const {
        return node1.fScore < node2.fScore;
    }
};

std::deque<Node> reconstructPath(std::unordered_map<Node, Node, NodeHash> cameFrom, Node current) {
    std::deque<Node> totalPath = {current};
   
    int i = 0;
    do {
        current = cameFrom.find(current)->second;
        totalPath.push_front(current);

        if (i > 4)
            break;
        i++;
    } while (cameFrom.find(current) != cameFrom.end());

    return totalPath;
}

std::deque<Node> A_Star(Node start, Node target) {

    //my_priority_queue<Node, std::vector<Node>, NodeComp> openSet; 
    std::set<Node, NodeComp> openSet = {start};
    std::set<Node, NodeComp> closedSet = {};
    //openSet.push(start);

    std::unordered_map<Node, Node, NodeHash> cameFrom;

    while (!openSet.empty()) {
        //Node current = openSet.top();
        Node current = *openSet.begin();

        // NOTE: comparison operation might have to be modified
        if (current == target) 
            return reconstructPath(cameFrom, current);

        for (const auto &node : openSet) {
            std::cout << node.fScore << std::endl;
        }
        std::cout << std::endl;

        //openSet.pop();

        std::vector<Node> neighbours = current.getNeighbours();
        for (Node neighbour : neighbours) {
            int32_t tentativeScore = current.gScore + current.getDistanceFrom(neighbour);

            neighbour.gScore = tentativeScore;
            neighbour.fScore = tentativeScore + neighbour.getDistanceFrom(target);
            cameFrom[neighbour] = current;

            if (closedSet.find(neighbour) != closedSet.end()) {
                if (neighbour.gScore > tentativeScore) {
                    closedSet.erase(neighbour);
                    openSet.insert(neighbour);
                }
            } else if (openSet.find(neighbour) == openSet.end()) {
                openSet.insert(neighbour);
            }

            /*if (tentativeScore < neighbour.gScore) {
                neighbour.gScore = tentativeScore;
                neighbour.fScore = tentativeScore + neighbour.getDistanceFrom(target);
                cameFrom[neighbour] = current;

                if (openSet.find(neighbour) == openSet.end())
                    //openSet.push(neighbour);
                    openSet.insert(neighbour);
            }*/
        }

        openSet.erase(current);
        closedSet.insert(current);
    }

    throw std::runtime_error("Open set is empty, but the target was never reached!");
}

int main()  
{
    // TODO: actually define a grid with obstacles to traverse
    Node target = {WIDTH - 1, HEIGHT - 1, std::numeric_limits<int32_t>::max(), std::numeric_limits<int32_t>::max()};
    Node start = {0, 0, 0, 0};

    start.fScore = start.getDistanceFrom(target);

    try {
        std::deque<Node> path = A_Star(start, target);

        for (const auto &node : path) 
            std::cout << "(" << node.x << ", " << node.y << ") ";
        std::cout << std::endl;

    } catch (const std::exception &e) {
        std::cerr << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
